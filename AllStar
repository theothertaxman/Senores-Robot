package LIJrobs;

import robocode.Robot;
import robocode.control.*;
import robocode.control.BattlefieldSpecification;
import java.util.HashMap;
import java.util.Iterator;
import java.util.TreeSet;


public class AllStar extends Robot {

    private RobotSetup[] map;
    private final int NumPixelRows = 13 * 64;
    private final int NumPixelCols = 10 * 64;

    //Generate map
    public AllStar() {
        super();
        int NumPixelRows = 13 * 64;
        int NumPixelCols = 10 * 64;
        BattlefieldSpecification battlefield = new BattlefieldSpecification(NumPixelRows, NumPixelCols);
        int NumObstacles = (int) Math.floor(((NumPixelRows / 64) * (NumPixelCols / 64)) * 30 / 100);
        long seed = (long) 23.12345;
        ObstacleGen m = new ObstacleGen(battlefield, NumObstacles + 2, seed);
        map = m.getObs();
    }


    private Node aStar() {
        //Initialize closed set
        TreeSet<Point> closed = new TreeSet<>();
        for (int c = 0; c < map.length - 2; c++) {
            closed.add(new Point(map[c]));
        }

        HashMap<Point, Node> open = new HashMap<>();
        Node current;
        current = new Node(new Point(3, 4));
        open.put(current.getPoint(), current);
        while (!open.isEmpty()) {
            current = cheapest(open);
            if (isGoal(current.getPoint())) {
                return current;
            }
            open.remove(current.getPoint());
            closed.add(current.getPoint());
            for (Node neighbour : current.neighbours()) {
                if (!closed.contains(neighbour.getPoint())) {
                    if (!open.containsKey(neighbour.getPoint())) {
                        open.put(neighbour.getPoint(), neighbour);
                    } else {
                        if (neighbour.getCost() < open.get(neighbour.getPoint()).getCost()) {
                            open.put(neighbour.getPoint(), neighbour);
                        }
                    }
                }
            }
        }
        throw new RuntimeException("Something went wrong while searching for a path");
    }

    private Node cheapest(HashMap op) {
       Node cheap = null, current = null;
       int g = 0,cur;
        Iterator<Node> it = op.values().iterator();
        if(it.hasNext()){
            cheap = it.next();
            g = current.getCost()+heuristic(current.getPoint());
        }
     while(it.hasNext()){
         current = it.next();
         cur = current.getCost()+heuristic(current.getPoint());
         if(cur < g){
             cheap = current;
         }
     }
     return cheap;
    }

    private boolean isGoal(Point p) {
        Point pt = new Point(map[map.length - 1]);
        return pt.equals(p);

    }

    private int heuristic(Point p){
        Point goal = new Point(map[map.length-1]);
        return Math.abs(goal.getX()-p.getX()) + Math.abs(goal.getY()-p.getY());
    }


    private class Node {

        Node parent;
        Point p;
        int cost;

        public Node(Node par, Point pt) {
            parent = par;
            p = pt;
            cost = par.getCost() + 1;
        }

        public Node(Point pt) {
            p = pt;
            cost = 0;
            parent = null;
        }

        public Point getPoint() {
            return p;
        }

        public int getCost() {
            return cost;
        }

        public Node[] neighbours() {
            Point up = new Point(p.getX(), p.getY() + 64);
            Point down = new Point(p.getX(), p.getY() - 64);
            Point right = new Point(p.getX() + 64, p.getY());
            Point left = new Point(p.getX() - 64, p.getY());
            int c = 0;
            Node[] neighbours = new Node[4];
            if (up.getY() < NumPixelRows) {
                Node a = new Node(this, up);
                neighbours[c] = a;
                c++;
            }
            if (down.getY() >= 0) {
                Node b = new Node(this, down);
                neighbours[c] = b;
                c++;
            }
            if (right.getX() < NumPixelCols) {
                Node cn = new Node(this, right);
                neighbours[c] = cn;
                c++;
            }
            if (left.getY() >= 0) {
                Node d = new Node(this, left);
                neighbours[c] = d;
                c++;
            }
            return neighbours;
        }
    }


    private class Point {
        int x;
        int y;

        Point(int n, int m) {
            x = n;
            y = m;
        }

        Point(RobotSetup r) {
            x = r.getX().intValue();
            y = r.getY().intValue();
        }

        int getX() {
            return x;
        }

        int getY() {
            return y;
        }

        boolean equals(Point p) {
            return (x == p.getX()) && (y == p.getY());
        }

    }

}
